package de.fe1k.game9.entities;

import de.fe1k.game9.components.Component;
import de.fe1k.game9.events.Event;
import de.fe1k.game9.events.EventEntityDestroyed;
import de.fe1k.game9.events.EventEntityMoved;
import de.fe1k.game9.events.EventEntitySpawned;
import de.fe1k.game9.exceptions.ComponentAlreadyExistsException;
import de.fe1k.game9.exceptions.MissingComponentDependenciesException;
import de.nerogar.noise.util.Vector2f;

import java.util.*;
import java.util.stream.Stream;

public class Entity {

	private final long id;

	private Vector2f position;
	private float    rotation;
	private Vector2f scale;

	private Entity(long id, Vector2f position) {
		this.id = id;
		this.position = position;
		this.rotation = 0;
		this.scale = new Vector2f(1);
	}

	private void throwOnMissingDependencies() {
		if (!getComponents(this).stream().allMatch(Component::dependenciesSatisfied)) {
			throw new MissingComponentDependenciesException();
		}
	}

	/**
	 * Looks up if the entity has a component by class.
	 *
	 * @param componentClass the component's class
	 * @return true if the entity has a component of that class, false otherwise
	 */
	public <T extends Component> boolean hasComponent(Class<T> componentClass) {
		return Entity.hasComponent(this, componentClass);
	}

	/**
	 * Adds a component to the entity. Removes it from the previous owner first, if it had one.
	 *
	 * @param component component to add
	 * @throws ComponentAlreadyExistsException if this entity already has a component of that class.
	 */
	public void addComponent(Component component) {
		Entity.addComponent(this, component);
	}

	/**
	 * Removes a component from the entity by component class.
	 *
	 * @param componentClass class of the components to remove.
	 * @return the component removed, or null if no component got removed.
	 */
	public <T extends Component> Component removeComponent(Class<T> componentClass) {
		return Entity.removeComponent(this, componentClass);
	}

	/**
	 * Looks up a component by class.
	 *
	 * @param clazz the component's class
	 * @return the component object for that class, or null if the entity doesn't have that component.
	 */
	@SuppressWarnings("unchecked")
	public <T extends Component> T getComponent(Class<T> clazz) {
		return Entity.getComponent(this, clazz);
	}

	public long getId() {
		return id;
	}

	public void teleport(Vector2f to) {
		if (to.equals(position)) {
			return;
		}
		Vector2f from = position.clone();
		position.set(to);
		Event.trigger(new EventEntityMoved(this, from, position.clone()));
	}

	public void move(Vector2f delta) {
		if (delta.getX() == 0 && delta.getY() == 0) {
			return;
		}
		Vector2f from = position.clone();
		position.add(delta);
		Event.trigger(new EventEntityMoved(this, from, position.clone()));
	}

	/**
	 * Getter for the position of this entity.
	 * DO NOT directly modify the vector returned by this, instead
	 * use the {@link #teleport(Vector2f)} or {@link #move(Vector2f)} method instead.
	 *
	 * @return position of this entity
	 */
	public Vector2f getPosition() {
		return position;
	}

	public float getRotation() {
		return rotation;
	}

	public void setRotation(float rotation) {
		this.rotation = rotation;
	}

	public Vector2f getScale() {
		return scale;
	}

	private void destroy() {
		for (Component component : Entity.getComponents(this)) {
			Entity.removeComponent(this, component.getClass());
			component.destroy();
		}
	}

	@Override
	public boolean equals(Object o) {
		// generated by IntelliJ IDEA
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;

		Entity entity = (Entity) o;

		return id == entity.id;
	}

	@Override
	public int hashCode() {
		// generated by IntelliJ IDEA
		return (int) (id ^ (id >>> 32));
	}

	@Override
	public String toString() {
		return "Entity{" +
				"id=" + id +
				'}';
	}

	////////////////// STATIC STUFF //////////////////

	private static class ComponentMap extends HashMap<Class<? extends Component>, Map<Entity, Component>> {}

	private static ComponentMap      componentMap;
	private static Map<Long, Entity> entities;
	private static Random            uniqueIdRandom;

	static {
		componentMap = new ComponentMap();
		entities = new HashMap<>();
		uniqueIdRandom = new Random();
	}

	public static Entity getById(long id) {
		return entities.get(id);
	}

	public static Stream<Entity> getAll() {
		return entities.values().stream();
	}

	/**
	 * Returns all entities that have all the given components specified by classes.
	 *
	 * @param componentClasses list of component classes to check for
	 * @return stream of entities that have all the components
	 */
	public static List<Entity> getAllWithComponentss(Class<? extends Component>... componentClasses) {
		List<Entity> entitiesWithComponents = new ArrayList<>();
		for (Entity entity : entities.values()) {
			if (Arrays.stream(componentClasses).allMatch(entity::hasComponent)) {
				entitiesWithComponents.add(entity);
			}
		}
		return entitiesWithComponents;
	}

	/**
	 * Returns all components of the given class
	 *
	 * @param componentClass the component's class
	 * @return list of components of that class
	 */
	@SuppressWarnings("unchecked")
	public static <T extends Component> Collection<T> getComponents(Class<T> componentClass) {
		return (Collection<T>) componentMap.get(componentClass).values();
	}

	/**
	 * Returns all components of the given class
	 *
	 * @param componentClass the component's class
	 * @return list of components of that class
	 */
	@SuppressWarnings("unchecked")
	public static <T extends Component> T getFirstComponent(Class<T> componentClass) {
		if (componentMap.get(componentClass).isEmpty()) {
			return null;
		}
		return (T) componentMap.get(componentClass).values().iterator().next();
	}

	public static Entity spawn(Vector2f position) {
		Entity entity = new Entity(getUniqueId(), position);
		entities.put(entity.getId(), entity);
		Event.trigger(new EventEntitySpawned(entity));
		return entity;
	}

	public static void despawn(long entityId) {
		Entity removedEntity = entities.remove(entityId);
		Event.trigger(new EventEntityDestroyed(removedEntity));
		removedEntity.destroy();
	}

	private static List<Component> getComponents(Entity entity) {
		List<Component> components = new ArrayList<>();
		for (Map<Entity, Component> entityComponentMap : componentMap.values()) {
			Component component = entityComponentMap.get(entity);
			if (component != null) {
				components.add(component);
			}
		}
		return components;
	}

	private static void addComponent(Entity entity, Component component) {
		Class<? extends Component> componentClass = component.getClass();
		Map<Entity, Component> components = componentMap.computeIfAbsent(componentClass, k -> new HashMap<>());
		if (components.containsKey(entity)) {
			throw new ComponentAlreadyExistsException();
		}
		components.put(entity, component);
		Entity previousOwner = component.getOwner();
		if (previousOwner != null) {
			previousOwner.removeComponent(component.getClass());
		}
		component.setOwner(entity);
		entity.throwOnMissingDependencies();
	}

	private static <T extends Component> T removeComponent(Entity entity, Class<T> componentClass) {
		@SuppressWarnings("unchecked") Map<Entity, T> components = (Map<Entity, T>) componentMap.get(componentClass);
		if (components == null) {
			return null;
		}
		T removedComponent = components.remove(entity);
		entity.throwOnMissingDependencies();
		if (removedComponent != null) {
			//removedComponent.setOwner(null);
		}
		return removedComponent;
	}

	private static boolean hasComponent(Entity entity, Class<? extends Component> componentClass) {
		Map<Entity, Component> components = componentMap.get(componentClass);
		return components != null && components.containsKey(entity);
	}

	private static <T extends Component> T getComponent(Entity entity, Class<T> componentClass) {
		@SuppressWarnings("unchecked") Map<Entity, T> components = (Map<Entity, T>) componentMap.get(componentClass);
		if (components == null) {
			return null;
		}
		return components.get(entity);
	}

	public static void despawnAll() {
		while (!entities.isEmpty()) {
			despawn(entities.values().iterator().next().getId());
		}
	}

	private static long getUniqueId() {
		return uniqueIdRandom.nextLong();
	}

}
